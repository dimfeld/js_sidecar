import l from"node:cluster";import k from"node:os";import w from"node:fs";import{parseArgs as $}from"node:util";import y from"node:net";import{EventEmitter as R}from"node:events";import*as d from"vm";var g=(e=>(e[e.RunScript=0]="RunScript",e[e.Ping=1]="Ping",e))(g||{}),p=(e=>(e[e.RunResponse=4096]="RunResponse",e[e.Log=4097]="Log",e[e.Error=4098]="Error",e[e.Pong=4099]="Pong",e))(p||{});const v=!!process.env.DEBUG_JS_SIDECAR_WORKER;function f(...e){v&&console.log(...e)}const b=12,x=0,E=4,S=8;class I extends R{socket;buffer;expectedLength;id;cache=new Map;constructor(o){super(),this.socket=o,this.buffer=Buffer.alloc(0),this.expectedLength=null,this.id=0,this.socket.on("data",t=>this.handleData(t))}handleData(o){for(this.buffer=Buffer.concat([this.buffer,o]);this.buffer.length>0;){if(this.expectedLength===null){if(this.buffer.length<4)return;this.expectedLength=this.buffer.readUInt32LE(0),this.buffer=this.buffer.subarray(4)}if(this.buffer.length<this.expectedLength)return;const t=this.buffer.readUInt32LE(x),n=this.buffer.readUInt32LE(E),r=this.buffer.readUInt32LE(S),s=this.buffer.subarray(12,this.expectedLength);this.buffer=this.buffer.subarray(this.expectedLength),this.expectedLength=null;const u={id:n,reqId:t,type:r,data:s};this.emit("message",u)}}sendMessage(o,t,n){f("Sending message",o,t,n),n instanceof Buffer||(n=Buffer.from(n));let r=this.id++;const s=Buffer.allocUnsafe(b+4);return s.writeUInt32LE(n.length+b),s.writeUInt32LE(o,x+4),s.writeUInt32LE(r,E+4),s.writeUInt32LE(t,S+4),this.socket.write(Buffer.concat([s,n])),r}log(o,t,n){let r=JSON.stringify({level:t,message:n});this.sendMessage(o,p.Log,r)}respond(o,t){this.sendMessage(o,p.RunResponse,JSON.stringify(t))}error(o,t){let n={message:t.message,stack:t.stack},r=JSON.stringify(n);this.sendMessage(o,p.Error,r)}}const L=Symbol("runCtx");function _(e,o){let t=o.recreateContext?void 0:e.protocol.cache.get(L);if(t){if(o.globals)for(const[n,r]of Object.entries(o.globals))t.context[n]=r}else{const n={log:(...s)=>e.log(s,"info"),info:(...s)=>e.log(s,"info"),warn:(...s)=>e.log(s,"warn"),error:(...s)=>e.log(s,"error")},r=d.createContext({...o.globals,console:n});t={modules:{},context:r},e.protocol.cache.set(L,t)}for(const n of o.functions??[])t.context[n.name]=d.compileFunction(n.code,n.params,{parsingContext:t.context});for(const n of o.modules??[])t.modules[n.name]=new d.SourceTextModule(n.code,{identifier:n.name,context:t.context});return t}async function O(e,o){let t=process.hrtime.bigint(),n=_(o,e),r;if(!e.code)return{};if(e.expr)r=d.runInContext(e.code,n.context,{filename:e.name||"<script>",timeout:e.timeoutMs??void 0}),typeof r?.then=="function"&&(r=await r);else{async function i(a,h){const m=n.modules[a];if(m)return m;throw new Error(`Module not found: ${a}, referenced from ${h.identifier}`)}let c=new d.SourceTextModule(e.code,{identifier:e.name||"<script>",context:n.context});await c.link(i),await c.evaluate()}const s=e.returnKeys?Object.fromEntries(e.returnKeys.map(i=>[i,n.context[i]])):n.context;let u=Number(process.hrtime.bigint()-t)/1e3;return f(`Evaluated in ${u}us`),{globals:s,returnValue:r}}function C(e){f(`Worker ${process.pid} started`);const o=y.createServer(),t=()=>{f(`Worker ${process.pid} is shutting down`),o.close(()=>process.exit(0))};process.on("message",r=>{f(`Worker ${process.pid} received message: ${r}`),r=="shutdown"&&(f(`Worker ${process.pid} received shutdown message`),t())}),l.worker?.send("ready"),process.on("SIGTERM",t),process.on("SIGINT",t);function n(r){let s=new I(r);s.on("message",u=>P(s,u))}o.on("error",r=>{console.error(r),process.exit(1)}),o.listen(e,()=>{f(`Worker ${process.pid} is listening on ${e}`),o.on("connection",n)})}function P(e,{id:o,reqId:t,type:n,data:r}){if(n===g.Ping){e.sendMessage(t,p.Pong,Buffer.alloc(0));return}let s=process.hrtime.bigint(),u=!1;const i={protocol:e,reqId:t,id:o,log(c,a="info"){f(`${t}[${a}]:`,c),e.log(t,a,c)},respond(c){u=!0,e.respond(t,c)},error(c){f(`${t}: `,c.message),e.error(t,c)}};G(i,n,r).then(c=>{(c!=null||!u)&&i.respond(c??null);let a=Number(process.hrtime.bigint()-s)/1e3;f(`handle: ${a}us`)}).catch(c=>{f("Failed to handle request:"),i.error(c)})}async function G(e,o,t){switch(o){case g.RunScript:return O(JSON.parse(t.toString()),e)}}if(l.isPrimary){let e=function(){if(s)return;let i=l.fork({SOCKET_PATH:r});i.on("message",c=>{c==="ready"&&s&&i.send("shutdown")})};const o=process.argv[1],{values:t}=$({options:{workers:{type:"string",default:k.cpus().length.toString()},socket:{type:"string"}}}),n=parseInt(t.workers??"1",10),r=t.socket;let s=!1;if(!r)throw new Error("No socket path provided");process.on("exit",()=>{try{w.unlinkSync(r)}catch{}});const u=()=>{f("shutting down"),s&&process.exit(1),s=!0;for(let i of Object.values(l.workers??{}))i?.send("shutdown",()=>{})};process.on("SIGTERM",u),process.on("SIGINT",u),l.on("online",i=>{f("online",i.process.pid,s),s&&i.kill("SIGKILL")}),l.on("exit",(i,c,a)=>{if(f("exit",i.process.pid,c,a,s,r),!s&&!w.existsSync(o)&&(f(`${r} script is gone, shutting down`),u()),s){const h=Object.values(l.workers??{}).map(m=>m?.process.pid);f(r,"remaining workers:",h),h.length==0&&process.exit(0);return}f(a?`Worker ${i.process.pid} died with signal ${a}. Restarting...`:`Worker ${i.process.pid} died with code ${c}. Restarting...`),e()}),f(`Primary ${process.pid} is running, starting ${n} workers and connecting to ${r}`);for(let i=0;i<n;i++)e()}else C(process.env.SOCKET_PATH);
//# sourceMappingURL=index.js.map
