import F from"node:cluster";import Q from"node:os";import $ from"node:fs";import{parseArgs as Z}from"node:util";import q from"node:net";import{EventEmitter as tt}from"node:events";import*as R from"node:vm";var k=(o=>(o[o.RunScript=0]="RunScript",o[o.Ping=1]="Ping",o))(k||{}),z=(o=>(o[o.RunResponse=4096]="RunResponse",o[o.Log=4097]="Log",o[o.Error=4098]="Error",o[o.Pong=4099]="Pong",o))(z||{});const et=!!process.env.DEBUG_JS_SIDECAR_WORKER;function p(...o){et&&console.log(...o)}const j=12,P=0,K=4,B=8;class it extends tt{socket;buffer;expectedLength;id;cache=new Map;constructor(t){super(),this.socket=t,this.buffer=Buffer.alloc(0),this.expectedLength=null,this.id=0,this.socket.on("data",e=>this.handleData(e))}handleData(t){for(this.buffer=Buffer.concat([this.buffer,t]);this.buffer.length>0;){if(this.expectedLength===null){if(this.buffer.length<4)return;this.expectedLength=this.buffer.readUInt32LE(0),this.buffer=this.buffer.subarray(4)}if(this.buffer.length<this.expectedLength)return;const e=this.buffer.readUInt32LE(P),i=this.buffer.readUInt32LE(K),s=this.buffer.readUInt32LE(B),n=this.buffer.subarray(12,this.expectedLength);this.buffer=this.buffer.subarray(this.expectedLength),this.expectedLength=null;const r={id:i,reqId:e,type:s,data:n};this.emit("message",r)}}sendMessage(t,e,i){p("Sending message",t,e,i),i instanceof Buffer||(i=Buffer.from(i));let s=this.id++;const n=Buffer.allocUnsafe(j+4);return n.writeUInt32LE(i.length+j),n.writeUInt32LE(t,P+4),n.writeUInt32LE(s,K+4),n.writeUInt32LE(e,B+4),this.socket.write(Buffer.concat([n,i])),s}log(t,e,i){let s=JSON.stringify({level:e,message:i});this.sendMessage(t,z.Log,s)}respond(t,e){this.sendMessage(t,z.RunResponse,JSON.stringify(e))}error(t,e){let i={message:e.message,stack:e.stack},s=JSON.stringify(i);this.sendMessage(t,z.Error,s)}}const T=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,H=new Set,I=typeof process=="object"&&process?process:{},Y=(o,t,e,i)=>{typeof I.emitWarning=="function"?I.emitWarning(o,t,e,i):console.error(`[${e}] ${t}: ${o}`)};let W=globalThis.AbortController,V=globalThis.AbortSignal;if(typeof W>"u"){V=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(i,s){this._onabort.push(s)}},W=class{constructor(){t()}signal=new V;abort(i){if(!this.signal.aborted){this.signal.reason=i,this.signal.aborted=!0;for(const s of this.signal._onabort)s(i);this.signal.onabort?.(i)}}};let o=I.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1";const t=()=>{o&&(o=!1,Y("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",t))}}const st=o=>!H.has(o),A=o=>o&&o===Math.floor(o)&&o>0&&isFinite(o),X=o=>A(o)?o<=Math.pow(2,8)?Uint8Array:o<=Math.pow(2,16)?Uint16Array:o<=Math.pow(2,32)?Uint32Array:o<=Number.MAX_SAFE_INTEGER?D:null:null;class D extends Array{constructor(t){super(t),this.fill(0)}}class x{heap;length;static#a=!1;static create(t){const e=X(t);if(!e)return[];x.#a=!0;const i=new x(t,e);return x.#a=!1,i}constructor(t,e){if(!x.#a)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class M{#a;#f;#g;#w;#R;#z;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#n;#m;#s;#i;#t;#l;#u;#h;#r;#S;#o;#b;#y;#d;#_;#O;#c;static unsafeExposeInternals(t){return{starts:t.#y,ttls:t.#d,sizes:t.#b,keyMap:t.#s,keyList:t.#i,valList:t.#t,next:t.#l,prev:t.#u,get head(){return t.#h},get tail(){return t.#r},free:t.#S,isBackgroundFetch:e=>t.#e(e),backgroundFetch:(e,i,s,n)=>t.#W(e,i,s,n),moveToTail:e=>t.#C(e),indexes:e=>t.#E(e),rindexes:e=>t.#A(e),isStale:e=>t.#p(e)}}get max(){return this.#a}get maxSize(){return this.#f}get calculatedSize(){return this.#m}get size(){return this.#n}get fetchMethod(){return this.#R}get memoMethod(){return this.#z}get dispose(){return this.#g}get disposeAfter(){return this.#w}constructor(t){const{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:n,updateAgeOnGet:r,updateAgeOnHas:a,allowStale:h,dispose:l,disposeAfter:w,noDisposeOnSet:c,noUpdateTTL:d,maxSize:u=0,maxEntrySize:v=0,sizeCalculation:g,fetchMethod:b,memoMethod:f,noDeleteOnFetchRejection:S,noDeleteOnStaleGet:_,allowStaleOnFetchRejection:m,allowStaleOnFetchAbort:y,ignoreFetchAbort:C}=t;if(e!==0&&!A(e))throw new TypeError("max option must be a nonnegative integer");const E=e?X(e):Array;if(!E)throw new Error("invalid max value: "+e);if(this.#a=e,this.#f=u,this.maxEntrySize=v||this.#f,this.sizeCalculation=g,this.sizeCalculation){if(!this.#f&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(f!==void 0&&typeof f!="function")throw new TypeError("memoMethod must be a function if defined");if(this.#z=f,b!==void 0&&typeof b!="function")throw new TypeError("fetchMethod must be a function if specified");if(this.#R=b,this.#O=!!b,this.#s=new Map,this.#i=new Array(e).fill(void 0),this.#t=new Array(e).fill(void 0),this.#l=new E(e),this.#u=new E(e),this.#h=0,this.#r=0,this.#S=x.create(e),this.#n=0,this.#m=0,typeof l=="function"&&(this.#g=l),typeof w=="function"?(this.#w=w,this.#o=[]):(this.#w=void 0,this.#o=void 0),this.#_=!!this.#g,this.#c=!!this.#w,this.noDisposeOnSet=!!c,this.noUpdateTTL=!!d,this.noDeleteOnFetchRejection=!!S,this.allowStaleOnFetchRejection=!!m,this.allowStaleOnFetchAbort=!!y,this.ignoreFetchAbort=!!C,this.maxEntrySize!==0){if(this.#f!==0&&!A(this.#f))throw new TypeError("maxSize must be a positive integer if specified");if(!A(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#$()}if(this.allowStale=!!h,this.noDeleteOnStaleGet=!!_,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!a,this.ttlResolution=A(s)||s===0?s:1,this.ttlAutopurge=!!n,this.ttl=i||0,this.ttl){if(!A(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#U()}if(this.#a===0&&this.ttl===0&&this.#f===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#a&&!this.#f){const L="LRU_CACHE_UNBOUNDED";st(L)&&(H.add(L),Y("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",L,M))}}getRemainingTTL(t){return this.#s.has(t)?1/0:0}#U(){const t=new D(this.#a),e=new D(this.#a);this.#d=t,this.#y=e,this.#I=(n,r,a=T.now())=>{if(e[n]=r!==0?a:0,t[n]=r,r!==0&&this.ttlAutopurge){const h=setTimeout(()=>{this.#p(n)&&this.#v(this.#i[n],"expire")},r+1);h.unref&&h.unref()}},this.#T=n=>{e[n]=t[n]!==0?T.now():0},this.#F=(n,r)=>{if(t[r]){const a=t[r],h=e[r];if(!a||!h)return;n.ttl=a,n.start=h,n.now=i||s();const l=n.now-h;n.remainingTTL=a-l}};let i=0;const s=()=>{const n=T.now();if(this.ttlResolution>0){i=n;const r=setTimeout(()=>i=0,this.ttlResolution);r.unref&&r.unref()}return n};this.getRemainingTTL=n=>{const r=this.#s.get(n);if(r===void 0)return 0;const a=t[r],h=e[r];if(!a||!h)return 1/0;const l=(i||s())-h;return a-l},this.#p=n=>{const r=e[n],a=t[n];return!!a&&!!r&&(i||s())-r>a}}#T=()=>{};#F=()=>{};#I=()=>{};#p=()=>!1;#$(){const t=new D(this.#a);this.#m=0,this.#b=t,this.#x=e=>{this.#m-=t[e],t[e]=0},this.#G=(e,i,s,n)=>{if(this.#e(i))return 0;if(!A(s))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(s=n(i,e),!A(s))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return s},this.#L=(e,i,s)=>{if(t[e]=i,this.#f){const n=this.#f-t[e];for(;this.#m>n;)this.#D(!0)}this.#m+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#m)}}#x=t=>{};#L=(t,e,i)=>{};#G=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#E({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#r;!(!this.#k(e)||((t||!this.#p(e))&&(yield e),e===this.#h));)e=this.#u[e]}*#A({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#h;!(!this.#k(e)||((t||!this.#p(e))&&(yield e),e===this.#r));)e=this.#l[e]}#k(t){return t!==void 0&&this.#s.get(this.#i[t])===t}*entries(){for(const t of this.#E())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#e(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*rentries(){for(const t of this.#A())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#e(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*keys(){for(const t of this.#E()){const e=this.#i[t];e!==void 0&&!this.#e(this.#t[t])&&(yield e)}}*rkeys(){for(const t of this.#A()){const e=this.#i[t];e!==void 0&&!this.#e(this.#t[t])&&(yield e)}}*values(){for(const t of this.#E())this.#t[t]!==void 0&&!this.#e(this.#t[t])&&(yield this.#t[t])}*rvalues(){for(const t of this.#A())this.#t[t]!==void 0&&!this.#e(this.#t[t])&&(yield this.#t[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(const i of this.#E()){const s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;if(n!==void 0&&t(n,this.#i[i],this))return this.get(this.#i[i],e)}}forEach(t,e=this){for(const i of this.#E()){const s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;n!==void 0&&t.call(e,n,this.#i[i],this)}}rforEach(t,e=this){for(const i of this.#A()){const s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;n!==void 0&&t.call(e,n,this.#i[i],this)}}purgeStale(){let t=!1;for(const e of this.#A({allowStale:!0}))this.#p(e)&&(this.#v(this.#i[e],"expire"),t=!0);return t}info(t){const e=this.#s.get(t);if(e===void 0)return;const i=this.#t[e],s=this.#e(i)?i.__staleWhileFetching:i;if(s===void 0)return;const n={value:s};if(this.#d&&this.#y){const r=this.#d[e],a=this.#y[e];if(r&&a){const h=r-(T.now()-a);n.ttl=h,n.start=Date.now()}}return this.#b&&(n.size=this.#b[e]),n}dump(){const t=[];for(const e of this.#E({allowStale:!0})){const i=this.#i[e],s=this.#t[e],n=this.#e(s)?s.__staleWhileFetching:s;if(n===void 0||i===void 0)continue;const r={value:n};if(this.#d&&this.#y){r.ttl=this.#d[e];const a=T.now()-this.#y[e];r.start=Math.floor(Date.now()-a)}this.#b&&(r.size=this.#b[e]),t.unshift([i,r])}return t}load(t){this.clear();for(const[e,i]of t){if(i.start){const s=Date.now()-i.start;i.start=T.now()-s}this.set(e,i.value,i)}}set(t,e,i={}){if(e===void 0)return this.delete(t),this;const{ttl:s=this.ttl,start:n,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:h}=i;let{noUpdateTTL:l=this.noUpdateTTL}=i;const w=this.#G(t,e,i.size||0,a);if(this.maxEntrySize&&w>this.maxEntrySize)return h&&(h.set="miss",h.maxEntrySizeExceeded=!0),this.#v(t,"set"),this;let c=this.#n===0?void 0:this.#s.get(t);if(c===void 0)c=this.#n===0?this.#r:this.#S.length!==0?this.#S.pop():this.#n===this.#a?this.#D(!1):this.#n,this.#i[c]=t,this.#t[c]=e,this.#s.set(t,c),this.#l[this.#r]=c,this.#u[c]=this.#r,this.#r=c,this.#n++,this.#L(c,w,h),h&&(h.set="add"),l=!1;else{this.#C(c);const d=this.#t[c];if(e!==d){if(this.#O&&this.#e(d)){d.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:u}=d;u!==void 0&&!r&&(this.#_&&this.#g?.(u,t,"set"),this.#c&&this.#o?.push([u,t,"set"]))}else r||(this.#_&&this.#g?.(d,t,"set"),this.#c&&this.#o?.push([d,t,"set"]));if(this.#x(c),this.#L(c,w,h),this.#t[c]=e,h){h.set="replace";const u=d&&this.#e(d)?d.__staleWhileFetching:d;u!==void 0&&(h.oldValue=u)}}else h&&(h.set="update")}if(s!==0&&!this.#d&&this.#U(),this.#d&&(l||this.#I(c,s,n),h&&this.#F(h,c)),!r&&this.#c&&this.#o){const d=this.#o;let u;for(;u=d?.shift();)this.#w?.(...u)}return this}pop(){try{for(;this.#n;){const t=this.#t[this.#h];if(this.#D(!0),this.#e(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(t!==void 0)return t}}finally{if(this.#c&&this.#o){const t=this.#o;let e;for(;e=t?.shift();)this.#w?.(...e)}}}#D(t){const e=this.#h,i=this.#i[e],s=this.#t[e];return this.#O&&this.#e(s)?s.__abortController.abort(new Error("evicted")):(this.#_||this.#c)&&(this.#_&&this.#g?.(s,i,"evict"),this.#c&&this.#o?.push([s,i,"evict"])),this.#x(e),t&&(this.#i[e]=void 0,this.#t[e]=void 0,this.#S.push(e)),this.#n===1?(this.#h=this.#r=0,this.#S.length=0):this.#h=this.#l[e],this.#s.delete(i),this.#n--,e}has(t,e={}){const{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,n=this.#s.get(t);if(n!==void 0){const r=this.#t[n];if(this.#e(r)&&r.__staleWhileFetching===void 0)return!1;if(this.#p(n))s&&(s.has="stale",this.#F(s,n));else return i&&this.#T(n),s&&(s.has="hit",this.#F(s,n)),!0}else s&&(s.has="miss");return!1}peek(t,e={}){const{allowStale:i=this.allowStale}=e,s=this.#s.get(t);if(s===void 0||!i&&this.#p(s))return;const n=this.#t[s];return this.#e(n)?n.__staleWhileFetching:n}#W(t,e,i,s){const n=e===void 0?void 0:this.#t[e];if(this.#e(n))return n;const r=new W,{signal:a}=i;a?.addEventListener("abort",()=>r.abort(a.reason),{signal:r.signal});const h={signal:r.signal,options:i,context:s},l=(g,b=!1)=>{const{aborted:f}=r.signal,S=i.ignoreFetchAbort&&g!==void 0;if(i.status&&(f&&!b?(i.status.fetchAborted=!0,i.status.fetchError=r.signal.reason,S&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),f&&!S&&!b)return c(r.signal.reason);const _=u;return this.#t[e]===u&&(g===void 0?_.__staleWhileFetching?this.#t[e]=_.__staleWhileFetching:this.#v(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,g,h.options))),g},w=g=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=g),c(g)),c=g=>{const{aborted:b}=r.signal,f=b&&i.allowStaleOnFetchAbort,S=f||i.allowStaleOnFetchRejection,_=S||i.noDeleteOnFetchRejection,m=u;if(this.#t[e]===u&&(!_||m.__staleWhileFetching===void 0?this.#v(t,"fetch"):f||(this.#t[e]=m.__staleWhileFetching)),S)return i.status&&m.__staleWhileFetching!==void 0&&(i.status.returnedStale=!0),m.__staleWhileFetching;if(m.__returned===m)throw g},d=(g,b)=>{const f=this.#R?.(t,n,h);f&&f instanceof Promise&&f.then(S=>g(S===void 0?void 0:S),b),r.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(g(void 0),i.allowStaleOnFetchAbort&&(g=S=>l(S,!0)))})};i.status&&(i.status.fetchDispatched=!0);const u=new Promise(d).then(l,w),v=Object.assign(u,{__abortController:r,__staleWhileFetching:n,__returned:void 0});return e===void 0?(this.set(t,v,{...h.options,status:void 0}),e=this.#s.get(t)):this.#t[e]=v,v}#e(t){if(!this.#O)return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof W}async fetch(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:h=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:w=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:d=this.allowStaleOnFetchRejection,ignoreFetchAbort:u=this.ignoreFetchAbort,allowStaleOnFetchAbort:v=this.allowStaleOnFetchAbort,context:g,forceRefresh:b=!1,status:f,signal:S}=e;if(!this.#O)return f&&(f.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,status:f});const _={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,ttl:r,noDisposeOnSet:a,size:h,sizeCalculation:l,noUpdateTTL:w,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:d,allowStaleOnFetchAbort:v,ignoreFetchAbort:u,status:f,signal:S};let m=this.#s.get(t);if(m===void 0){f&&(f.fetch="miss");const y=this.#W(t,m,_,g);return y.__returned=y}else{const y=this.#t[m];if(this.#e(y)){const N=i&&y.__staleWhileFetching!==void 0;return f&&(f.fetch="inflight",N&&(f.returnedStale=!0)),N?y.__staleWhileFetching:y.__returned=y}const C=this.#p(m);if(!b&&!C)return f&&(f.fetch="hit"),this.#C(m),s&&this.#T(m),f&&this.#F(f,m),y;const E=this.#W(t,m,_,g),U=E.__staleWhileFetching!==void 0&&i;return f&&(f.fetch=C?"stale":"refresh",U&&C&&(f.returnedStale=!0)),U?E.__staleWhileFetching:E.__returned=E}}async forceFetch(t,e={}){const i=await this.fetch(t,e);if(i===void 0)throw new Error("fetch() returned undefined");return i}memo(t,e={}){const i=this.#z;if(!i)throw new Error("no memoMethod provided to constructor");const{context:s,forceRefresh:n,...r}=e,a=this.get(t,r);if(!n&&a!==void 0)return a;const h=i(t,a,{options:r,context:s});return this.set(t,h,r),h}get(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:r}=e,a=this.#s.get(t);if(a!==void 0){const h=this.#t[a],l=this.#e(h);return r&&this.#F(r,a),this.#p(a)?(r&&(r.get="stale"),l?(r&&i&&h.__staleWhileFetching!==void 0&&(r.returnedStale=!0),i?h.__staleWhileFetching:void 0):(n||this.#v(t,"expire"),r&&i&&(r.returnedStale=!0),i?h:void 0)):(r&&(r.get="hit"),l?h.__staleWhileFetching:(this.#C(a),s&&this.#T(a),h))}else r&&(r.get="miss")}#M(t,e){this.#u[e]=t,this.#l[t]=e}#C(t){t!==this.#r&&(t===this.#h?this.#h=this.#l[t]:this.#M(this.#u[t],this.#l[t]),this.#M(this.#r,t),this.#r=t)}delete(t){return this.#v(t,"delete")}#v(t,e){let i=!1;if(this.#n!==0){const s=this.#s.get(t);if(s!==void 0)if(i=!0,this.#n===1)this.#N(e);else{this.#x(s);const n=this.#t[s];if(this.#e(n)?n.__abortController.abort(new Error("deleted")):(this.#_||this.#c)&&(this.#_&&this.#g?.(n,t,e),this.#c&&this.#o?.push([n,t,e])),this.#s.delete(t),this.#i[s]=void 0,this.#t[s]=void 0,s===this.#r)this.#r=this.#u[s];else if(s===this.#h)this.#h=this.#l[s];else{const r=this.#u[s];this.#l[r]=this.#l[s];const a=this.#l[s];this.#u[a]=this.#u[s]}this.#n--,this.#S.push(s)}}if(this.#c&&this.#o?.length){const s=this.#o;let n;for(;n=s?.shift();)this.#w?.(...n)}return i}clear(){return this.#N("delete")}#N(t){for(const e of this.#A({allowStale:!0})){const i=this.#t[e];if(this.#e(i))i.__abortController.abort(new Error("deleted"));else{const s=this.#i[e];this.#_&&this.#g?.(i,s,t),this.#c&&this.#o?.push([i,s,t])}}if(this.#s.clear(),this.#t.fill(void 0),this.#i.fill(void 0),this.#d&&this.#y&&(this.#d.fill(0),this.#y.fill(0)),this.#b&&this.#b.fill(0),this.#h=0,this.#r=0,this.#S.length=0,this.#m=0,this.#n=0,this.#c&&this.#o){const e=this.#o;let i;for(;i=e?.shift();)this.#w?.(...i)}}}const O=new M({max:128});function G(o,t,e){return[o?"esm":"cjs",t,...e||[]].join("\0")}const J=Symbol("runCtx");function nt(o,t){let e=t.recreateContext?void 0:o.protocol.cache.get(J);if(e){if(t.globals)for(const[i,s]of Object.entries(t.globals))e.context[i]=s}else{const i={log:(...n)=>o.log(n,"info"),info:(...n)=>o.log(n,"info"),warn:(...n)=>o.log(n,"warn"),error:(...n)=>o.log(n,"error")},s=R.createContext({...t.globals,console:i});e={modules:{},context:s},o.protocol.cache.set(J,e)}for(const i of t.functions??[]){let s=G(!1,i.code,i.params),n=O.get(s),r=R.compileFunction(i.code,i.params,{parsingContext:e.context,cachedData:n,produceCachedData:!n});e.context[i.name]=r}for(const i of t.modules??[]){const s=G(!0,i.code);let n=O.get(s),r=new R.SourceTextModule(i.code,{identifier:i.name,context:e.context,cachedData:n});if(!n){let a=r.createCachedData();O.set(s,a)}e.modules[i.name]=r}return e}async function rt(o,t){let e=process.hrtime.bigint(),i=nt(t,o),s;if(!o.code)return{};const n=G(!o.expr,o.code);if(o.expr){let h=O.get(n),l=new R.Script(o.code,{filename:o.name||"<script>",cachedData:h});h||O.set(n,l.createCachedData()),s=l.runInContext(i.context,{timeout:o.timeoutMs??void 0}),typeof s?.then=="function"&&(s=await s)}else{async function h(c,d){const u=i.modules[c];if(u)return u;throw new Error(`Module not found: ${c}, referenced from ${d.identifier}`)}let l=O.get(n),w=new R.SourceTextModule(o.code,{identifier:o.name||"<script>",context:i.context,cachedData:l});if(!l){let c=w.createCachedData();c&&O.set(n,c)}await w.link(h),await w.evaluate()}const r=o.returnKeys?Object.fromEntries(o.returnKeys.map(h=>[h,i.context[h]])):i.context;let a=Number(process.hrtime.bigint()-e)/1e3;return p(`Evaluated in ${a}us`),{globals:r,returnValue:s}}function ot(o){p(`Worker ${process.pid} started`);const t=q.createServer(),e=()=>{p(`Worker ${process.pid} is shutting down`),t.close(()=>process.exit(0))};process.on("message",s=>{p(`Worker ${process.pid} received message: ${s}`),s=="shutdown"&&(p(`Worker ${process.pid} received shutdown message`),e())}),F.worker?.send("ready"),process.on("SIGTERM",e),process.on("SIGINT",e);function i(s){let n=new it(s);n.on("message",r=>ht(n,r))}t.on("error",s=>{console.error(s),process.exit(1)}),t.listen(o,()=>{p(`Worker ${process.pid} is listening on ${o}`),t.on("connection",i)})}function ht(o,{id:t,reqId:e,type:i,data:s}){if(i===k.Ping){o.sendMessage(e,z.Pong,Buffer.alloc(0));return}let n=process.hrtime.bigint(),r=!1;const a={protocol:o,reqId:e,id:t,log(h,l="info"){p(`${e}[${l}]:`,h),o.log(e,l,h)},respond(h){r=!0,o.respond(e,h)},error(h){p(`${e}: `,h.message),o.error(e,h)}};at(a,i,s).then(h=>{(h!=null||!r)&&a.respond(h??null);let l=Number(process.hrtime.bigint()-n)/1e3;p(`handle: ${l}us`)}).catch(h=>{p("Failed to handle request:"),a.error(h)})}async function at(o,t,e){switch(t){case k.RunScript:return rt(JSON.parse(e.toString()),o)}}if(F.isPrimary){let o=function(){if(n)return;let a=F.fork({SOCKET_PATH:s});a.on("message",h=>{h==="ready"&&n&&a.send("shutdown")})};const t=process.argv[1],{values:e}=Z({options:{workers:{type:"string",default:Q.cpus().length.toString()},socket:{type:"string"}}}),i=parseInt(e.workers??"1",10),s=e.socket;let n=!1;if(!s)throw new Error("No socket path provided");process.on("exit",()=>{try{$.unlinkSync(s)}catch{}});const r=()=>{p("shutting down"),n&&process.exit(1),n=!0;for(let a of Object.values(F.workers??{}))a?.send("shutdown",()=>{})};process.on("SIGTERM",r),process.on("SIGINT",r),F.on("online",a=>{p("online",a.process.pid,n),n&&a.kill("SIGKILL")}),F.on("exit",(a,h,l)=>{if(p("exit",a.process.pid,h,l,n,s),!n&&!$.existsSync(t)&&(p(`${s} script is gone, shutting down`),r()),n){const w=Object.values(F.workers??{}).map(c=>c?.process.pid);p(s,"remaining workers:",w),w.length==0&&process.exit(0);return}p(l?`Worker ${a.process.pid} died with signal ${l}. Restarting...`:`Worker ${a.process.pid} died with code ${h}. Restarting...`),o()}),p(`Primary ${process.pid} is running, starting ${i} workers and connecting to ${s}`);for(let a=0;a<i;a++)o()}else ot(process.env.SOCKET_PATH);
//# sourceMappingURL=index.js.map
