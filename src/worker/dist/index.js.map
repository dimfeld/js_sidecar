{"version":3,"file":"index.js","sources":["../src/api_types.ts","../src/debug.ts","../src/protocol.ts","../node_modules/.pnpm/lru-cache@11.0.0/node_modules/lru-cache/dist/esm/index.js","../src/run_script.ts","../src/worker.ts","../src/index.ts"],"sourcesContent":["// Types that are used when communicating with the host, together for easy reference.\n\n// Message types\n// Host-to-worker\nexport enum HostToWorkerMessage {\n  /** Run a script, optionally supplying globals and code modules. */\n  RunScript = 0,\n  /** Host checking connection integrity */\n  Ping = 1,\n}\n\n// Worker-to-host\nexport enum WorkerToHostMessage {\n  RunResponse = 0x1000,\n  Log = 0x1001,\n  Error = 0x1002,\n  Pong = 0x1003,\n}\n\n/** A function to be injected into the context. */\nexport interface FunctionDef {\n  name: string;\n  params: string[];\n  code: string;\n}\n\n/** A ES Module to be importable by the script */\nexport interface CodeModule {\n  name: string;\n  code: string;\n}\n\n/** Data associated with the RunScript message */\nexport interface RunScriptArgs {\n  name: string;\n\n  /** The code to run. This can be omitted if the message is just initializing the context for later runs. */\n  code?: string;\n\n  /** Recreate the run context instead of reusing the context from the previous run on this\n   * connection. */\n  recreateContext?: boolean;\n\n  /** If true, the code is just a simple expression and should run on its own.\n   Expression mode supports returning a value directly, but does not support specifying `modules`. */\n  expr?: boolean;\n\n  /** Global variables to set in the context. */\n  globals?: object;\n\n  /** How long to wait for the script to complete. */\n  timeoutMs?: number;\n\n  /** Functions to compile and place in the global scope */\n  functions?: FunctionDef[];\n\n  /** ES Modules to make available for the code to import. */\n  modules?: CodeModule[];\n\n  /** If set, return only these keys from the context. If omitted, the entire global context is returned. */\n  returnKeys?: string[];\n}\n\nexport interface RunResponse {\n  globals?: object;\n  returnValue?: any;\n}\n\nexport interface ErrorResponse {\n  message: string;\n  stack?: string;\n}\n\nexport interface LogMessage {\n  level: string;\n  message: string | object;\n}\n","const enabled = !!process.env.DEBUG_JS_SIDECAR_WORKER;\n\nexport function debug(...args: any[]) {\n  if (enabled) {\n    console.log(...args);\n  }\n}\n","import net from 'node:net';\nimport { EventEmitter } from 'node:events';\nimport { HostToWorkerMessage, WorkerToHostMessage, type RunResponse } from './api_types.js';\nimport { debug } from './debug.js';\n\nexport interface IncomingMessage {\n  id: number;\n  reqId: number;\n  type: HostToWorkerMessage;\n  data: Buffer;\n}\n\n// Header *without* the length field\nconst MSG_HEADER_LENGTH = 12;\n\n// Offsets from just after the length field.\nconst REQ_ID_OFFSET = 0;\nconst MSG_ID_OFFSET = 4;\nconst MSG_TYPE_OFFSET = 8;\n\n/** A simple protocol in which each message has an ID, a type, and some data\n *\n *  Format\n *\n *  0: length\n *  4: request ID, links the message to a particular run\n *  8: message ID, unique per message within a request\n *  12: message type\n *  ... type-specific data follows\n * */\nexport class Protocol extends EventEmitter<{ message: [IncomingMessage] }> {\n  socket: net.Socket;\n  buffer: Buffer;\n  expectedLength: number | null;\n  id: number;\n\n  cache: Map<any, any> = new Map();\n\n  constructor(socket: net.Socket) {\n    super();\n    this.socket = socket;\n    this.buffer = Buffer.alloc(0);\n    this.expectedLength = null;\n    this.id = 0;\n    this.socket.on('data', (data) => this.handleData(data));\n  }\n\n  handleData(data: Buffer) {\n    this.buffer = Buffer.concat([this.buffer, data]);\n\n    while (this.buffer.length > 0) {\n      if (this.expectedLength === null) {\n        if (this.buffer.length < 4) {\n          // Not enough data yet to read length\n          return;\n        }\n        this.expectedLength = this.buffer.readUInt32LE(0);\n        this.buffer = this.buffer.subarray(4);\n      }\n\n      // Not enough data for full message\n      if (this.buffer.length < this.expectedLength) {\n        return;\n      }\n\n      const reqId = this.buffer.readUInt32LE(REQ_ID_OFFSET);\n      const id = this.buffer.readUInt32LE(MSG_ID_OFFSET);\n      const type = this.buffer.readUInt32LE(MSG_TYPE_OFFSET);\n      const data = this.buffer.subarray(12, this.expectedLength);\n\n      // Remove the message from the pending buffer\n      this.buffer = this.buffer.subarray(this.expectedLength);\n      this.expectedLength = null;\n\n      const message = {\n        id,\n        reqId,\n        type,\n        data,\n      };\n\n      // Emit the received message\n      this.emit('message', message);\n    }\n  }\n\n  sendMessage(reqId: number, type: WorkerToHostMessage, message: string | Buffer) {\n    debug('Sending message', reqId, type, message);\n    if (!(message instanceof Buffer)) {\n      message = Buffer.from(message);\n    }\n\n    let id = this.id++;\n    const header = Buffer.allocUnsafe(MSG_HEADER_LENGTH + 4);\n    header.writeUInt32LE(message.length + MSG_HEADER_LENGTH);\n    header.writeUInt32LE(reqId, REQ_ID_OFFSET + 4);\n    header.writeUInt32LE(id, MSG_ID_OFFSET + 4);\n    header.writeUInt32LE(type, MSG_TYPE_OFFSET + 4);\n\n    this.socket.write(Buffer.concat([header, message]));\n    return id;\n  }\n\n  log(reqId: number, level: string, message: string | object) {\n    let data = JSON.stringify({ level, message });\n    this.sendMessage(reqId, WorkerToHostMessage.Log, data);\n  }\n\n  respond(reqId: number, data: RunResponse) {\n    this.sendMessage(reqId, WorkerToHostMessage.RunResponse, JSON.stringify(data));\n  }\n\n  error(reqId: number, e: Error) {\n    let message = { message: e.message, stack: e.stack };\n\n    let data = JSON.stringify(message);\n    this.sendMessage(reqId, WorkerToHostMessage.Error, data);\n  }\n}\n","/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRLUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","import * as vm from 'vm';\nimport type { MessageContext } from './types.js';\nimport type { RunResponse, RunScriptArgs } from './api_types.js';\nimport { debug } from './debug.js';\nimport { LRUCache } from 'lru-cache';\n\nconst codeCache = new LRUCache<string, Buffer>({\n  max: 128,\n});\n\nfunction codeCacheKey(esm: boolean, code: string, params?: string[]) {\n  const startKey = esm ? 'esm' : 'cjs';\n  return [startKey, code, ...(params || [])].join('\\0');\n}\n\nconst RUN_CTX_KEY = Symbol('runCtx');\n\ninterface RunContext {\n  modules: Record<string, vm.Module>;\n  context: vm.Context;\n}\n\nfunction createContext(ctx: MessageContext, args: RunScriptArgs): RunContext {\n  let runCtx: RunContext = args.recreateContext ? undefined : ctx.protocol.cache.get(RUN_CTX_KEY);\n\n  if (!runCtx) {\n    const scriptConsole = {\n      log: (...args: any[]) => ctx.log(args, 'info'),\n      info: (...args: any[]) => ctx.log(args, 'info'),\n      warn: (...args: any[]) => ctx.log(args, 'warn'),\n      error: (...args: any[]) => ctx.log(args, 'error'),\n    };\n\n    const jsCtx = vm.createContext({\n      ...args.globals,\n      console: scriptConsole,\n    });\n\n    runCtx = {\n      modules: {},\n      context: jsCtx,\n    };\n\n    // Save the context for reuse later.\n    ctx.protocol.cache.set(RUN_CTX_KEY, runCtx);\n  } else if (args.globals) {\n    for (const [key, value] of Object.entries(args.globals)) {\n      runCtx.context[key] = value;\n    }\n  }\n\n  for (const fn of args.functions ?? []) {\n    let cacheKey = codeCacheKey(false, fn.code, fn.params);\n    let cachedData = codeCache.get(cacheKey);\n    let compiled = vm.compileFunction(fn.code, fn.params, {\n      parsingContext: runCtx.context,\n      cachedData,\n      produceCachedData: !cachedData,\n    });\n\n    runCtx.context[fn.name] = compiled;\n  }\n\n  for (const modArgs of args.modules ?? []) {\n    const cacheKey = codeCacheKey(true, modArgs.code);\n    let cachedData = codeCache.get(cacheKey);\n    let mod = new vm.SourceTextModule(modArgs.code, {\n      identifier: modArgs.name,\n      context: runCtx.context,\n      cachedData,\n    });\n\n    if (!cachedData) {\n      let data = mod.createCachedData();\n      codeCache.set(cacheKey, data);\n    }\n\n    runCtx.modules[modArgs.name] = mod;\n  }\n\n  return runCtx;\n}\n\nexport async function runScript(args: RunScriptArgs, ctx: MessageContext): Promise<RunResponse> {\n  let start = process.hrtime.bigint();\n  let run = createContext(ctx, args);\n\n  let retVal;\n\n  if (!args.code) {\n    // The user sent no code, this was only to update the context for future runs.\n    return {};\n  }\n\n  const cacheKey = codeCacheKey(!args.expr, args.code);\n  if (args.expr) {\n    let cacheData = codeCache.get(cacheKey);\n    let script = new vm.Script(args.code, {\n      filename: args.name || '<script>',\n      cachedData: cacheData,\n    });\n\n    if (!cacheData) {\n      codeCache.set(cacheKey, script.createCachedData());\n    }\n\n    retVal = script.runInContext(run.context, {\n      timeout: args.timeoutMs ?? undefined,\n    });\n\n    if (typeof retVal?.then === 'function') {\n      retVal = await retVal;\n    }\n  } else {\n    async function doLink(specifier: string, referencingModule: vm.Module) {\n      const mod = run.modules[specifier];\n      if (mod) {\n        return mod;\n      }\n\n      throw new Error(\n        `Module not found: ${specifier}, referenced from ${referencingModule.identifier}`\n      );\n    }\n\n    let cachedData = codeCache.get(cacheKey);\n    let mod = new vm.SourceTextModule(args.code, {\n      identifier: args.name || '<script>',\n      context: run.context,\n      cachedData,\n    });\n\n    if (!cachedData) {\n      let data = mod.createCachedData();\n      if (data) {\n        codeCache.set(cacheKey, data);\n      }\n    }\n\n    await mod.link(doLink);\n    await mod.evaluate();\n  }\n\n  const outputGlobals = args.returnKeys\n    ? Object.fromEntries(args.returnKeys.map((key) => [key, run.context[key]]))\n    : run.context;\n  let elapsed = Number(process.hrtime.bigint() - start) / 1e3;\n  debug(`Evaluated in ${elapsed}us`);\n  return {\n    globals: outputGlobals,\n    returnValue: retVal,\n  };\n}\n","import net from 'node:net';\nimport cluster from 'node:cluster';\nimport { Protocol, type IncomingMessage } from './protocol.js';\nimport type { MessageContext } from './types.js';\nimport { runScript } from './run_script.js';\nimport { HostToWorkerMessage, WorkerToHostMessage } from './api_types.js';\nimport { debug } from './debug.js';\n\nexport function runWorker(socketPath: string) {\n  debug(`Worker ${process.pid} started`);\n  const server = net.createServer();\n  const shutdown = () => {\n    debug(`Worker ${process.pid} is shutting down`);\n    server.close(() => process.exit(0));\n  };\n\n  process.on('message', (msg) => {\n    debug(`Worker ${process.pid} received message: ${msg}`);\n    if (msg == 'shutdown') {\n      debug(`Worker ${process.pid} received shutdown message`);\n      shutdown();\n    }\n  });\n\n  // Tell the primary that we are now listening to messages. This prevents a race condition\n  // where shutdown triggers while this worker is starting up, and so the shutdown messages\n  // arrives before we are listening for them.\n  cluster.worker?.send('ready');\n\n  process.on('SIGTERM', shutdown);\n  process.on('SIGINT', shutdown);\n\n  function accept(socket: net.Socket) {\n    let protocol = new Protocol(socket);\n    protocol.on('message', (message) => handleRawMessage(protocol, message));\n  }\n\n  server.on('error', (e) => {\n    console.error(e);\n    process.exit(1);\n  });\n\n  server.listen(socketPath, () => {\n    debug(`Worker ${process.pid} is listening on ${socketPath}`);\n    server.on('connection', accept);\n  });\n}\n\nfunction handleRawMessage(protocol: Protocol, { id, reqId, type, data }: IncomingMessage) {\n  if (type === HostToWorkerMessage.Ping) {\n    protocol.sendMessage(reqId, WorkerToHostMessage.Pong, Buffer.alloc(0));\n    return;\n  }\n\n  let start = process.hrtime.bigint();\n\n  let sentResponse = false;\n  const context: MessageContext = {\n    protocol,\n    reqId,\n    id,\n    log(message: any, level: keyof Console = 'info') {\n      debug(`${reqId}[${level}]:`, message);\n      protocol.log(reqId, level, message);\n    },\n    respond(data: any) {\n      sentResponse = true;\n      protocol.respond(reqId, data);\n    },\n    error(e: Error) {\n      debug(`${reqId}: `, e.message);\n      protocol.error(reqId, e);\n    },\n  };\n\n  handleMessage(context, type, data)\n    .then((response) => {\n      if (response != undefined || !sentResponse) {\n        context.respond(response ?? null);\n      }\n\n      let elapsed = Number(process.hrtime.bigint() - start) / 1e3;\n      debug(`handle: ${elapsed}us`);\n    })\n    .catch((e) => {\n      debug('Failed to handle request:');\n      context.error(e);\n    });\n}\n\nasync function handleMessage(\n  ctx: MessageContext,\n  type: HostToWorkerMessage,\n  data: Buffer\n): Promise<any> {\n  switch (type) {\n    case HostToWorkerMessage.RunScript: {\n      return runScript(JSON.parse(data.toString()), ctx);\n    }\n  }\n}\n","import cluster from 'node:cluster';\nimport os from 'node:os';\nimport fs from 'node:fs';\nimport { parseArgs } from 'node:util';\n\nimport { runWorker } from './worker.js';\nimport { debug } from './debug.js';\n\nif (cluster.isPrimary) {\n  const filename = process.argv[1];\n\n  // Parse command line arguments\n  const { values } = parseArgs({\n    options: {\n      workers: {\n        type: 'string',\n        default: os.cpus().length.toString(),\n      },\n      socket: {\n        type: 'string',\n      },\n    },\n  });\n\n  const numWorkers = parseInt(values.workers ?? '1', 10);\n  const socketPath = values.socket;\n  let shuttingDown = false;\n\n  if (!socketPath) {\n    throw new Error('No socket path provided');\n  }\n\n  process.on('exit', () => {\n    // Make sure to clean up the socket file when the process exits\n    try {\n      fs.unlinkSync(socketPath);\n    } catch (e) {}\n  });\n\n  function forkWorker() {\n    if (shuttingDown) {\n      return;\n    }\n\n    let worker = cluster.fork({\n      SOCKET_PATH: socketPath,\n    });\n\n    worker.on('message', (msg) => {\n      if (msg === 'ready' && shuttingDown) {\n        // We started shutting down between when this worker was forked and when it\n        // started listening to messages, so tell it again.\n        worker.send('shutdown');\n      }\n    });\n  }\n\n  const shutdown = () => {\n    debug('shutting down');\n    if (shuttingDown) {\n      // Double SIGINT means the shutdown is taking longer than the user wants, so just quit now.\n      process.exit(1);\n    }\n\n    shuttingDown = true;\n    for (let worker of Object.values(cluster.workers ?? {})) {\n      worker?.send('shutdown', () => {});\n    }\n  };\n\n  process.on('SIGTERM', shutdown);\n  process.on('SIGINT', shutdown);\n\n  cluster.on('online', (worker) => {\n    debug('online', worker.process.pid, shuttingDown);\n    if (shuttingDown) {\n      worker.kill('SIGKILL');\n    }\n  });\n\n  cluster.on('exit', (worker, code, signal) => {\n    debug('exit', worker.process.pid, code, signal, shuttingDown, socketPath);\n    if (!shuttingDown && !fs.existsSync(filename)) {\n      // This happens when the Rust side shuts down somewhat uncleanly.\n      debug(`${socketPath} script is gone, shutting down`);\n      shutdown();\n    }\n\n    if (shuttingDown) {\n      const remainingWorkers = Object.values(cluster.workers ?? {}).map((w) => w?.process.pid);\n      debug(socketPath, 'remaining workers:', remainingWorkers);\n      if (remainingWorkers.length == 0) {\n        process.exit(0);\n      }\n      return;\n    }\n\n    if (signal) {\n      debug(`Worker ${worker.process.pid} died with signal ${signal}. Restarting...`);\n    } else {\n      debug(`Worker ${worker.process.pid} died with code ${code}. Restarting...`);\n    }\n    forkWorker();\n  });\n\n  debug(\n    `Primary ${process.pid} is running, starting ${numWorkers} workers and connecting to ${socketPath}`\n  );\n\n  for (let i = 0; i < numWorkers; i++) {\n    forkWorker();\n  }\n} else {\n  runWorker(process.env.SOCKET_PATH as string);\n}\n"],"names":["HostToWorkerMessage","WorkerToHostMessage","enabled","debug","args","MSG_HEADER_LENGTH","REQ_ID_OFFSET","MSG_ID_OFFSET","MSG_TYPE_OFFSET","Protocol","EventEmitter","socket","data","reqId","id","type","message","header","level","perf","warned","PROCESS","emitWarning","msg","code","fn","AC","AS","_","warnACPolyfill","reason","printACPolyfillWarning","shouldWarn","isPosInt","n","getUintArray","max","ZeroArray","size","Stack","#constructing","HeapCls","s","LRUCache","#max","#maxSize","#dispose","#disposeAfter","#fetchMethod","#memoMethod","#size","#calculatedSize","#keyMap","#keyList","#valList","#next","#prev","#head","#tail","#free","#disposed","#sizes","#starts","#ttls","#hasDispose","#hasFetchMethod","#hasDisposeAfter","c","p","#isBackgroundFetch","k","index","options","context","#backgroundFetch","#moveToTail","#indexes","#rindexes","#isStale","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","dispose","disposeAfter","noDisposeOnSet","noUpdateTTL","maxSize","maxEntrySize","sizeCalculation","fetchMethod","memoMethod","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchRejection","allowStaleOnFetchAbort","ignoreFetchAbort","UintArray","#initializeSizeTracking","#initializeTTLTracking","key","ttls","starts","#setItemTTL","start","t","#delete","#updateItemAge","#statusTTL","status","cachedNow","getNow","age","sizes","#removeItemSize","#requireSize","v","#addItemSize","#evict","_i","_s","_st","_k","_v","i","#isValidIndex","getOptions","value","thisp","deleted","entry","remain","arr","setOptions","oldVal","oldValue","dt","task","val","free","head","hasOptions","peekOptions","ac","signal","fetchOpts","cb","updateCache","aborted","ignoreAbort","fetchFail","bf","eb","er","allowStaleAborted","noDelete","pcall","res","rej","fmp","b","fetchOptions","forceRefresh","stale","isStale","staleVal","memoOptions","vv","fetching","#connect","#clear","pi","ni","codeCache","codeCacheKey","esm","params","RUN_CTX_KEY","createContext","ctx","runCtx","scriptConsole","jsCtx","vm","cacheKey","cachedData","compiled","modArgs","mod","runScript","run","retVal","cacheData","script","doLink","specifier","referencingModule","outputGlobals","elapsed","runWorker","socketPath","server","net","shutdown","cluster","accept","protocol","handleRawMessage","e","sentResponse","handleMessage","response","forkWorker","shuttingDown","worker","filename","values","parseArgs","os","numWorkers","fs","remainingWorkers","w"],"mappings":"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","x_google_ignoreList":[3]}