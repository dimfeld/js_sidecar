{"version":3,"file":"index.js","sources":["../src/api_types.ts","../src/protocol.ts","../src/run_script.ts","../src/debug.ts","../src/worker.ts","../src/index.ts"],"sourcesContent":["// Types that are used when communicating with the host, together for easy reference.\n\n// Message types\n// Host-to-worker\nexport enum HostToWorkerMessage {\n  /** Run a script, optionally supplying globals and code modules. */\n  RunScript = 0,\n}\n\n// Worker-to-host\nexport enum WorkerToHostMessage {\n  RunResponse = 0x1000,\n  Log = 0x1001,\n  Error = 0x1002,\n}\n\n/** A function to be injected into the context. */\nexport interface FunctionDef {\n  name: string;\n  params: string[];\n  code: string;\n}\n\n/** A ES Module to be importable by the script */\nexport interface CodeModule {\n  name: string;\n  code: string;\n}\n\n/** Data associated with the RunScript message */\nexport interface RunScriptArgs {\n  name: string;\n\n  /** The code to run. This can be omitted if the message is just initializing the context for later runs. */\n  code?: string;\n\n  /** Recreate the run context instead of reusing the context from the previous run on this\n   * connection. */\n  recreateContext?: boolean;\n\n  /** If true, the code is just a simple expression and should run on its own.\n   Expression mode supports returning a value directly, but does not support specifying `modules`. */\n  expr?: boolean;\n\n  /** Global variables to set in the context. */\n  globals?: object;\n\n  /** How long to wait for the script to complete. */\n  timeoutMs?: number;\n\n  /** Functions to compile and place in the global scope */\n  functions?: FunctionDef[];\n\n  /** ES Modules to make available for the code to import. */\n  modules?: CodeModule[];\n\n  /** If set, return only these keys from the context. If omitted, the entire global context is returned. */\n  returnKeys?: string[];\n}\n\nexport interface RunResponse {\n  globals?: object;\n  returnValue?: any;\n}\n\nexport interface ErrorResponse {\n  message: string;\n  stack?: string;\n}\n\nexport interface LogMessage {\n  level: string;\n  message: string | object;\n}\n","import net from 'node:net';\nimport { EventEmitter } from 'node:events';\nimport { HostToWorkerMessage, WorkerToHostMessage, type RunResponse } from './api_types.js';\n\nexport interface IncomingMessage {\n  id: number;\n  reqId: number;\n  type: HostToWorkerMessage;\n  data: Buffer;\n}\n\n// Header *without* the length field\nconst MSG_HEADER_LENGTH = 12;\n\n// Offsets from just after the length field.\nconst REQ_ID_OFFSET = 0;\nconst MSG_ID_OFFSET = 4;\nconst MSG_TYPE_OFFSET = 8;\n\n/** A simple protocol in which each message has an ID, a type, and some data\n *\n *  Format\n *\n *  0: length\n *  4: request ID, links the message to a particular run\n *  8: message ID, unique per message within a request\n *  12: message type\n *  ... type-specific data follows\n * */\nexport class Protocol extends EventEmitter<{ message: [IncomingMessage] }> {\n  socket: net.Socket;\n  buffer: Buffer;\n  expectedLength: number | null;\n  id: number;\n\n  cache: Map<any, any> = new Map();\n\n  constructor(socket: net.Socket) {\n    super();\n    this.socket = socket;\n    this.buffer = Buffer.alloc(0);\n    this.expectedLength = null;\n    this.id = 0;\n    this.socket.on('data', (data) => this.handleData(data));\n  }\n\n  handleData(data: Buffer) {\n    this.buffer = Buffer.concat([this.buffer, data]);\n\n    while (this.buffer.length > 0) {\n      if (this.expectedLength === null) {\n        if (this.buffer.length < 4) {\n          // Not enough data yet to read length\n          return;\n        }\n        this.expectedLength = this.buffer.readUInt32LE(0);\n        this.buffer = this.buffer.subarray(4);\n      }\n\n      // Not enough data for full message\n      if (this.buffer.length < this.expectedLength) {\n        return;\n      }\n\n      const reqId = this.buffer.readUInt32LE(REQ_ID_OFFSET);\n      const id = this.buffer.readUInt32LE(MSG_ID_OFFSET);\n      const type = this.buffer.readUInt32LE(MSG_TYPE_OFFSET);\n      const data = this.buffer.subarray(12, this.expectedLength);\n\n      // Remove the message from the pending buffer\n      this.buffer = this.buffer.subarray(this.expectedLength);\n      this.expectedLength = null;\n\n      const message = {\n        id,\n        reqId,\n        type,\n        data,\n      };\n\n      // Emit the received message\n      this.emit('message', message);\n    }\n  }\n\n  sendMessage(reqId: number, type: WorkerToHostMessage, message: string | Buffer) {\n    let id = this.id++;\n    const header = Buffer.allocUnsafe(MSG_HEADER_LENGTH + 4);\n    header.writeUInt32LE(message.length + MSG_HEADER_LENGTH);\n    header.writeUInt32LE(reqId, REQ_ID_OFFSET + 4);\n    header.writeUInt32LE(id, MSG_ID_OFFSET + 4);\n    header.writeUInt32LE(type, MSG_TYPE_OFFSET + 4);\n\n    if (!(message instanceof Buffer)) {\n      message = Buffer.from(message);\n    }\n\n    this.socket.write(Buffer.concat([header, message]));\n    return id;\n  }\n\n  log(reqId: number, level: string, message: string | object) {\n    let data = JSON.stringify({ level, message });\n    this.sendMessage(reqId, WorkerToHostMessage.Log, data);\n  }\n\n  respond(reqId: number, data: RunResponse) {\n    this.sendMessage(reqId, WorkerToHostMessage.RunResponse, JSON.stringify(data));\n  }\n\n  error(reqId: number, e: Error) {\n    let message = { message: e.message, stack: e.stack };\n\n    let data = JSON.stringify(message);\n    this.sendMessage(reqId, WorkerToHostMessage.Error, data);\n  }\n}\n","import * as vm from 'vm';\nimport type { MessageContext } from './types.js';\nimport type { RunResponse, RunScriptArgs } from './api_types.js';\n\nconst RUN_CTX_KEY = Symbol('runCtx');\n\ninterface RunContext {\n  modules: Record<string, vm.Module>;\n  context: vm.Context;\n}\n\nfunction createContext(ctx: MessageContext, args: RunScriptArgs): RunContext {\n  let runCtx: RunContext = args.recreateContext ? undefined : ctx.protocol.cache.get(RUN_CTX_KEY);\n\n  if (!runCtx) {\n    const scriptConsole = {\n      log: (...args: any[]) => ctx.log(args, 'info'),\n      info: (...args: any[]) => ctx.log(args, 'info'),\n      warn: (...args: any[]) => ctx.log(args, 'warn'),\n      error: (...args: any[]) => ctx.log(args, 'error'),\n    };\n\n    const jsCtx = vm.createContext({\n      ...args.globals,\n      console: scriptConsole,\n    });\n\n    runCtx = {\n      modules: {},\n      context: jsCtx,\n    };\n\n    // Save the context for reuse later.\n    ctx.protocol.cache.set(RUN_CTX_KEY, runCtx);\n  } else if (args.globals) {\n    for (const [key, value] of Object.entries(args.globals)) {\n      runCtx.context[key] = value;\n    }\n  }\n\n  for (const fn of args.functions ?? []) {\n    runCtx.context[fn.name] = vm.compileFunction(fn.code, fn.params, {\n      parsingContext: runCtx.context,\n    });\n  }\n\n  for (const modArgs of args.modules ?? []) {\n    runCtx.modules[modArgs.name] = new vm.SourceTextModule(modArgs.code, {\n      identifier: modArgs.name,\n      context: runCtx.context,\n    });\n  }\n\n  return runCtx;\n}\n\nexport async function runScript(args: RunScriptArgs, ctx: MessageContext): Promise<RunResponse> {\n  let run = createContext(ctx, args);\n\n  let retVal;\n\n  if (!args.code) {\n    // The user sent no code, this was only to update the context for future runs.\n    return {};\n  }\n\n  if (args.expr) {\n    retVal = vm.runInContext(args.code, run.context, {\n      filename: args.name,\n      timeout: args.timeoutMs,\n    });\n\n    if (typeof retVal?.then === 'function') {\n      retVal = await retVal;\n    }\n  } else {\n    async function doLink(specifier: string, referencingModule: vm.Module) {\n      const mod = run.modules[specifier];\n      if (mod) {\n        return mod;\n      }\n\n      throw new Error(\n        `Module not found: ${specifier}, referenced from ${referencingModule.identifier}`\n      );\n    }\n\n    let mod = new vm.SourceTextModule(args.code, { identifier: args.name, context: run.context });\n    await mod.link(doLink);\n    await mod.evaluate();\n  }\n\n  const outputGlobals = args.returnKeys\n    ? Object.fromEntries(args.returnKeys.map((key) => [key, run.context[key]]))\n    : run.context;\n  return {\n    globals: outputGlobals,\n    returnValue: retVal,\n  };\n}\n","const enabled = !!process.env.DEBUG_JS_SIDECAR_WORKER;\n\nexport function debug(...args: any[]) {\n  if (enabled) {\n    console.log(...args);\n  }\n}\n","import net from 'node:net';\nimport cluster from 'node:cluster';\nimport { Protocol, type IncomingMessage } from './protocol.js';\nimport type { MessageContext } from './types.js';\nimport { runScript } from './run_script.js';\nimport { HostToWorkerMessage } from './api_types.js';\nimport { debug } from './debug.js';\n\nexport function runWorker(socketPath: string) {\n  debug(`Worker ${process.pid} started`);\n  const server = net.createServer();\n  const shutdown = () => {\n    debug(`Worker ${process.pid} is shutting down`);\n    server.close(() => process.exit(0));\n  };\n\n  process.on('message', (msg) => {\n    debug(`Worker ${process.pid} received message: ${msg}`);\n    if (msg == 'shutdown') {\n      debug(`Worker ${process.pid} received shutdown message`);\n      shutdown();\n    }\n  });\n\n  // Tell the primary that we are now listening to messages. This prevents a race condition\n  // where shutdown triggers while this worker is starting up, and so the shutdown messages\n  // arrives before we are listening for them.\n  cluster.worker?.send('ready');\n\n  process.on('SIGTERM', shutdown);\n  process.on('SIGINT', shutdown);\n\n  function accept(socket: net.Socket) {\n    let protocol = new Protocol(socket);\n    protocol.on('message', (message) => handleRawMessage(protocol, message));\n  }\n\n  server.on('error', (e) => {\n    debug(e);\n    process.exit(1);\n  });\n\n  server.listen(socketPath, () => {\n    debug(`Worker ${process.pid} is listening on ${socketPath}`);\n    server.on('connection', accept);\n  });\n}\n\nfunction handleRawMessage(protocol: Protocol, { id, reqId, type, data }: IncomingMessage) {\n  let sentResponse = false;\n  const context: MessageContext = {\n    protocol,\n    reqId,\n    id,\n    log(message: any, level: keyof Console = 'info') {\n      debug(`${reqId}[${level}]:`, message);\n      protocol.log(reqId, level, message);\n    },\n    respond(data: any) {\n      sentResponse = true;\n      protocol.respond(reqId, data);\n    },\n    error(e: Error) {\n      debug(`${reqId}: `, e.message);\n      protocol.error(reqId, e);\n    },\n  };\n\n  handleMessage(context, type, data)\n    .then((response) => {\n      if (response != undefined || !sentResponse) {\n        context.respond(response ?? null);\n      }\n    })\n    .catch((e) => {\n      debug('Failed to handle request:');\n      context.error(e);\n    });\n}\n\nasync function handleMessage(\n  ctx: MessageContext,\n  type: HostToWorkerMessage,\n  data: Buffer\n): Promise<any> {\n  switch (type) {\n    case HostToWorkerMessage.RunScript: {\n      return runScript(JSON.parse(data.toString()), ctx);\n    }\n  }\n}\n","import cluster from 'node:cluster';\nimport os from 'node:os';\nimport fs from 'node:fs';\nimport { parseArgs } from 'node:util';\n\nimport { runWorker } from './worker.js';\nimport { debug } from './debug.js';\n\nif (cluster.isPrimary) {\n  const filename = process.argv[1];\n\n  // Parse command line arguments\n  const { values } = parseArgs({\n    options: {\n      workers: {\n        type: 'string',\n        default: os.cpus().length.toString(),\n      },\n      socket: {\n        type: 'string',\n      },\n    },\n  });\n\n  const numWorkers = parseInt(values.workers ?? '1', 10);\n  const socketPath = values.socket;\n  let shuttingDown = false;\n\n  if (!socketPath) {\n    throw new Error('No socket path provided');\n  }\n\n  process.on('exit', () => {\n    // Make sure to clean up the socket file when the process exits\n    try {\n      fs.unlinkSync(socketPath);\n    } catch (e) {}\n  });\n\n  function forkWorker() {\n    if (shuttingDown) {\n      return;\n    }\n\n    let worker = cluster.fork({\n      SOCKET_PATH: socketPath,\n    });\n\n    worker.on('message', (msg) => {\n      if (msg === 'ready' && shuttingDown) {\n        // We started shutting down between when this worker was forked and when it\n        // started listening to messages, so tell it again.\n        worker.send('shutdown');\n      }\n    });\n  }\n\n  const shutdown = () => {\n    debug('shutting down');\n    if (shuttingDown) {\n      // Double SIGINT means the shutdown is taking longer than the user wants, so just quit now.\n      process.exit(1);\n    }\n\n    shuttingDown = true;\n    for (let worker of Object.values(cluster.workers ?? {})) {\n      worker?.send('shutdown', () => {});\n    }\n  };\n\n  process.on('SIGTERM', shutdown);\n  process.on('SIGINT', shutdown);\n\n  cluster.on('online', (worker) => {\n    debug('online', worker.process.pid, shuttingDown);\n    if (shuttingDown) {\n      worker.kill('SIGKILL');\n    }\n  });\n\n  cluster.on('exit', (worker, code, signal) => {\n    debug('exit', worker.process.pid, code, signal, shuttingDown, socketPath);\n    if (!shuttingDown && !fs.existsSync(filename)) {\n      // This happens when the Rust side shuts down somewhat uncleanly.\n      debug(`${socketPath} script is gone, shutting down`);\n      shutdown();\n    }\n\n    if (shuttingDown) {\n      const remainingWorkers = Object.values(cluster.workers ?? {}).map((w) => w?.process.pid);\n      debug(socketPath, 'remaining workers:', remainingWorkers);\n      if (remainingWorkers.length == 0) {\n        process.exit(0);\n      }\n      return;\n    }\n\n    if (signal) {\n      debug(`Worker ${worker.process.pid} died with signal ${signal}. Restarting...`);\n    } else {\n      debug(`Worker ${worker.process.pid} died with code ${code}. Restarting...`);\n    }\n    forkWorker();\n  });\n\n  debug(\n    `Primary ${process.pid} is running, starting ${numWorkers} workers and connecting to ${socketPath}`\n  );\n\n  for (let i = 0; i < numWorkers; i++) {\n    forkWorker();\n  }\n} else {\n  runWorker(process.env.SOCKET_PATH as string);\n}\n"],"names":["HostToWorkerMessage","WorkerToHostMessage","MSG_HEADER_LENGTH","REQ_ID_OFFSET","MSG_ID_OFFSET","MSG_TYPE_OFFSET","Protocol","EventEmitter","socket","data","reqId","id","type","message","header","level","e","RUN_CTX_KEY","createContext","ctx","args","runCtx","key","value","scriptConsole","jsCtx","vm","fn","modArgs","runScript","run","retVal","doLink","specifier","referencingModule","mod","enabled","debug","runWorker","socketPath","server","net","shutdown","msg","cluster","accept","protocol","handleRawMessage","sentResponse","context","handleMessage","response","forkWorker","shuttingDown","worker","filename","values","parseArgs","os","numWorkers","fs","code","signal","remainingWorkers","w","i"],"mappings":"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"}